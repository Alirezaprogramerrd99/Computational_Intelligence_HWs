# -*- coding: utf-8 -*-
"""HW4_Q3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1toRfUZm4b4OBarnO3dYFzzEWOMYw2rvS

# Q3_Alireza Rashidi

## Importing important libs:
"""

import numpy as np
import pandas as pd
import random
from random import randint
import matplotlib.pyplot as plt

"""## Creating initial data of our Problem:"""

item_number = np.arange(1, 16)
TOTAL_ITEMS = item_number.shape[0]
price = np.array([12, 10, 5, 2, 10, 10, 10, 8, 12, 14, 16, 17, 18, 20, 1])
weight = np.array([14, 15, 12, 10, 2, 5, 18, 14, 10, 8, 14, 15, 16, 19, 1])
KNAPSACK_CAPACITY = 300   
print('item_idx  weight  price\n')
for i in range(TOTAL_ITEMS):
    print('{0}        {1}        {2}\n'.format(item_number[i], weight[i], price[i]))

"""## Creating GA parameters for problem:"""

population_size = 10
pop_format = (population_size, TOTAL_ITEMS)
print('population per generation: {}\n'.format(population_size))
print('Population size: {}'.format(pop_format))

# we have binary encoding for this problem each gene index corresponds to item index in the list.
# each gene has a value '1' or '0' which means the corresponding item is present or not.
condition = True

while condition:
    initial_population = np.random.randint(2, size = pop_format, dtype=int)
    a = np.count_nonzero(initial_population == 1, axis=0)
    count = np.count_nonzero(a > 5)
    count2 = np.count_nonzero(a >= 1)
    if count < 1 and count2 == TOTAL_ITEMS:
        condition = False

generations = 100
print('Initial random population: \n{}'.format(initial_population))

def fitness_function(weight, price, population, capacity):

    fitness = np.empty(population.shape[0])
    for individual in range(population.shape[0]):

        gene_price = np.sum(population[individual] * price) # scalar value...
        gene_weight = np.sum(population[individual] * weight)

        if gene_weight <= capacity:
            fitness[individual] = gene_price
        else:
            fitness[individual] = 0 
    return fitness.astype(int)


def selection(fitness, num_parents, population):
    fitness = list(fitness)
    parents = np.empty((num_parents, population.shape[1]))      # -> (size_population/2, len of chromosome)

    for chro in range(num_parents):
        max_fitness_idx = np.where(fitness == np.max(fitness))  # Return elements chosen from x or y depending on condition.
        parents[chro,:] = population[max_fitness_idx[0][0], :]
        fitness[max_fitness_idx[0][0]] = -999999
    return parents

def crossover(parents, num_offsprings):
    offsprings = np.empty((num_offsprings, parents.shape[1]))
    crossover_point = int(parents.shape[1] / 2)

    crossover_rate = 0.80
    individual = 0

    while (parents.shape[0] < num_offsprings):

        parent1_index = individual % parents.shape[0]
        parent2_index = (individual + 1) % parents.shape[0]

        coin_toss = random.random()

        if coin_toss > crossover_rate:
            continue

        parent1_index = individual % parents.shape[0]
        parent2_index = (individual + 1) % parents.shape[0]

        offsprings[individual, 0:crossover_point] = parents[parent1_index, 0:crossover_point]
        offsprings[individual, crossover_point:] = parents[parent2_index, crossover_point:]
        individual =+ 1
    return offsprings

def mutation(offsprings):
    
    mutation_rate = 0.35
    mutants = np.empty((offsprings.shape))
    for individaul in range(mutants.shape[0]):

        # copy offsprings to mutated list for applying mutation opration.
        mutants[individaul,:] = offsprings[individaul,:]
        coin_toss = random.random()

        if coin_toss > mutation_rate:
            continue
        random_gene = randint(0, offsprings.shape[1]-1)    

        # by chance flip the random bits of each individual...
        if mutants[individaul, random_gene] == 0:
            mutants[individaul, random_gene] = 1
        else:
            mutants[individaul, random_gene] = 0

    return mutants


def GA(weight, price, population, pop_size, generations, capacity):

    parameters, fitness_history = [], []
    num_parents = int(population.shape[0] / 2) # dividing half of population for older parents and half of it for new generations...
    num_offsprings = population.shape[0] - num_parents 

    for i in range(generations):

        fitness = fitness_function(weight, price, population, capacity)
        fitness_history.append(fitness)
        # selection and crossover oprations... 
        parents = selection(fitness, num_parents, population)
        offsprings = crossover(parents, num_offsprings)

        mutants = mutation(offsprings)
        # new population replacement....
        population[0:parents.shape[0], :] = parents   # half for parents 
        population[parents.shape[0]:, :] = mutants    # half for children

        print('\n-->>Generation number {} fitness = {}'.format(i+1, fitness))
        
    fitness_last_gen = fitness_function(weight, price, population, capacity)      
    print('Fitness of the last generation: \n{}\n'.format(fitness_last_gen))

    max_fitness = np.where(fitness_last_gen == np.max(fitness_last_gen))
    opt_row_idx = max_fitness[0][0]
    parameters.append(population[opt_row_idx,:])

    return parameters, fitness_history

parameters, fitness_history = GA(weight, price, initial_population, pop_format, generations, KNAPSACK_CAPACITY)

print('The optimized parameters for the given inputs are: \n{}'.format(parameters))
selected_items = item_number * parameters  # item_number[i] * 0 or 1 that shows what item that we can pick from bag

item_selected = []
for i in range(selected_items.shape[1]):
  if selected_items[0][i] != 0:
      item_selected.append(selected_items[0][i])
print('\nitems that we can pick from bag: ', item_selected)

print(fitness_history)

fitness_history_mean = [np.mean(fitness_individual) for fitness_individual in fitness_history]
fitness_history_max = [np.max(fitness_individual) for fitness_individual in fitness_history]

"""## Showing optimization using plot fitness vs generation numbers:"""

plt.plot(range(1, generations+1), fitness_history_mean, label = 'mean of fitness values')
plt.plot(range(1, generations+1), fitness_history_max, label = 'max of fitness values')
plt.legend()
plt.xlabel('generations')
plt.ylabel('fitness function value')