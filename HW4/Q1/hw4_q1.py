# -*- coding: utf-8 -*-
"""HW4_Q1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hGk79gJZRQy_3O7Hh1VILgzxwvCTQuKp

# Q1_Alireza Rashidi

## Working with Data:
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv("/content/BTC-USDT.csv", thousands=',')
reversed_df = df.iloc[::-1].reset_index(drop=True)
reversed_df

dayes = np.array(list( range(len(reversed_df))))
prices = reversed_df['Price'].to_numpy()
(dayes, prices)   # features: dayes,

POPULATION_SIZE = 100
chromosome_size = 5

first_days, sec_days, true_prices= prices[:100], prices[100:200], prices[200:300]

a, b = 0, 20
# generating initial population:
# one individual -> [gain, a, b, c, d] -> f(x) = (gain*a)x' - bx + c - d
def generate_individual(a, b, chromosome_size):
    return np.random.randint(a, b, chromosome_size) 
# [np.random.randint(0, 2, 10).tolist() for _ in range(POPULATION_SIZE)]

def init_population(size, a, b, chromosome_size):
    population = []
    for i in range(size):
        individual_chromosome = generate_individual(a, b , chromosome_size)
        population.append(individual_chromosome)
    return population

def fitness_func(chromosome):
    preds = (chromosome[0] * chromosome[1] * sec_days) - (chromosome[2] * first_days) + chromosome[3] - chromosome[4]
    return np.average( (true_prices - preds)**2 ) # using MSE for objective function.

def selection(population, scores, k=3):
	# first random selection
	selection_ix = np.random.randint(len(population))
	for ix in np.random.randint(0, len(population), k-1):
		# check if better (e.g. perform a tournament)
		if scores[ix] < scores[selection_ix]:
			selection_ix = ix
	return population[selection_ix]

def crossover(p1, p2, r_cross):
	# children are copies of parents by default
	c1, c2 = p1.copy(), p2.copy()
	# check for recombination
	if np.random.rand() < r_cross:
		# select crossover point that is not on the end of the string
		crossover_point = np.random.randint(1, len(p1)-1)
		# perform crossover
		c1 = np.concatenate( (p1[:crossover_point], p2[crossover_point:]), axis=0)
		c2 = np.concatenate( (p2[:crossover_point], p1[crossover_point:]), axis=0)
	return [c1, c2]

def mutation(chromosome, r_mut):
	for i in range(len(chromosome)):
		# check for a mutation
		if np.random.rand() < r_mut:
			chromosome[i] = np.random.randint(a, b)

def genetic_algorithm(fitness_func, generations, n_pop, chromosome_size, r_cross, r_mut):
    score_lst = []
    pop = init_population(n_pop, a, b, chromosome_size)
    best, best_eval = 0, fitness_func(pop[0])
    for gen in range(generations):
        scores = [fitness_func(c) for c in pop]
        for i in range(n_pop):
            if scores[i] < best_eval:
                best, best_eval = pop[i], scores[i]
                score_lst.append(best_eval)
                print(">generation: %d, new best f(%s) = %.3f" % (gen,  pop[i], scores[i]))
        selected = [selection(pop, scores) for _ in range(n_pop)]
        children = []
        for i in range(0, n_pop, 2):
            p1, p2 = selected[i], selected[i+1]
            for c in crossover(p1, p2, r_cross):
                mutation(c, r_mut)
                children.append(c)
        pop = children
    return best, best_eval, score_lst

best, best_eval, score_lst = genetic_algorithm(fitness_func, 1000, POPULATION_SIZE, chromosome_size, 0.80, 0.45)

plt.plot(score_lst, range(1, len(score_lst) + 1))
plt.xlabel('scores')
plt.ylabel('number of scores')

preds = (best[0] * best[1] * sec_days) - (best[2] * first_days) + best[3] - best[4]
preds